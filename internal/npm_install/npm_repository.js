'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const process = require("process");
function log_verbose(...m) {
    if (!!process.env['VERBOSE_LOGS'])
        console.error('[generate_build_file.ts]', ...m);
}
const args = process.argv.slice(2);
const WORKSPACE = args[0];
const LOCK_FILE_PATH = args[1];
if (require.main === module) {
    main();
    process.exit(1);
}
function mkdirp(p) {
    if (!fs.existsSync(p)) {
        mkdirp(path.dirname(p));
        fs.mkdirSync(p);
    }
}
function writeFileSync(p, content) {
    mkdirp(path.dirname(p));
    fs.writeFileSync(p, content);
}
function main() {
    const pkgs = findPackages(LOCK_FILE_PATH);
    let flattenPkgs = new Map();
    flattenDependencies(flattenPkgs, pkgs);
    const packagesBzl = generatePackagesBzl(Array.from(flattenPkgs.values()));
    writeFileSync('packages.bzl', packagesBzl);
    writeFileSync('.bazelignore', 'node_modules');
    writeFileSync('BUILD', '');
    writeFileSync('WORKSPACE', ` # DO NOT EDIT: automatically generated WORKSPACE file for npm_repositories rule
workspace(name = "${WORKSPACE}")
`);
}
exports.main = main;
function findPackages(packageLock) {
    const stripBom = (s) => s.charCodeAt(0) === 0xFEFF ? s.slice(1) : s;
    let lockData = JSON.parse(stripBom(fs.readFileSync(packageLock, { encoding: 'utf8' })));
    return extractPackages(lockData.dependencies);
}
function extractPackages(dependencies) {
    const pkgs = [];
    const deps = dependencies || [];
    Object.keys(deps).forEach((name) => {
        let pkg = {};
        pkg._name = name;
        pkg._repoName = repoName(name, deps[name]);
        pkg._version = deps[name].version;
        pkg._resolved = deps[name].resolved;
        pkg._integrity = deps[name].integrity;
        pkg._requires = deps[name].requires;
        pkg._dependencies = extractPackages(deps[name].dependencies);
        pkgs.push(pkg);
    });
    return pkgs;
}
function flattenDependencies(flattenPkgs, pkgs) {
    pkgs.forEach((pkg) => {
        if (!flattenPkgs.has(pkg._repoName)) {
            flattenPkgs.set(pkg._repoName, pkg);
            flattenDependencies(flattenPkgs, pkg._dependencies);
        }
    });
}
function repoName(name, dep) {
    const version = dep.version || dep._version;
    return `npm__${name.replace(/\@/g, '_').replace(/\'/g, '_').replace(/\-/g, '_').replace(/\//g, '_').replace(/\./g, '_')}__${version.replace(/\./g, '_')}`;
}
function npm_package(pkg) {
    const deps = ('_dependencies' in pkg) ? pkg._dependencies : [];
    const required_repos = deps.map((dep) => `"${repoName(dep._name, dep)}"`);
    return `
  if "${pkg._repoName}" not in native.existing_rules():
    install_package(
      name = "${pkg._repoName}",
      pkg = "${pkg._name}",
      version = "${pkg._version}",
      integrity = "${pkg._integrity}",
      required_repos = [${required_repos.join(',')}],
      npm_args = npm_args,
    )
 `;
}
function generatePackagesBzl(pkgs) {
    const packages = pkgs.map(pkg => npm_package(pkg));
    const mappings = pkgs.map(pkg => `"${pkg._name}": "@${pkg._repoName}//:pkg"`);
    return ` # Generated by npm_repositories rule
load("@build_bazel_rules_nodejs//internal/npm_install:npm_install.bzl", "install_package")

def install_packages(npm_args=[]):
  ${packages.join('\n')}

_packages = {
  ${mappings.join(',')}
}

all_packages = _packages.values()

def require(name, target=None):
  name_key = name.lower()
  if name_key not in _packages:
    fail("Could not find npm-provided dependency: '%s'" % name)
  req = _packages[name_key]
  if target != None:
    pkg, _, _ = req.partition("//")
    req = pkg + target
  return req
`;
}
