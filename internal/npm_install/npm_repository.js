"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const process = require("process");
function log_verbose(...m) {
    if (!!process.env["VERBOSE_LOGS"])
        console.error("[generate_build_file.ts]", ...m);
}
const args = process.argv.slice(2);
const WORKSPACE = args[0];
const LOCK_FILE_PATH = args[1];
if (require.main === module) {
    main();
}
function mkdirp(p) {
    if (!fs.existsSync(p)) {
        mkdirp(path.dirname(p));
        fs.mkdirSync(p);
    }
}
function writeFileSync(p, content) {
    mkdirp(path.dirname(p));
    fs.writeFileSync(p, content);
}
function main() {
    const pkgs = findPackages(LOCK_FILE_PATH);
    let flattenPkgs = new Map();
    flattenDependencies(flattenPkgs, pkgs);
    log_verbose(`${WORKSPACE} has ${flattenPkgs.size} dependencies in total`);
    const packagesBzl = generatePackagesBzl(Array.from(flattenPkgs.values()), pkgs);
    writeFileSync("packages.bzl", packagesBzl);
    writeFileSync(".bazelignore", "node_modules");
    writeFileSync("BUILD", "");
}
exports.main = main;
function findPackages(packageLock) {
    const stripBom = (s) => (s.charCodeAt(0) === 0xfeff ? s.slice(1) : s);
    let lockData = JSON.parse(stripBom(fs.readFileSync(packageLock, { encoding: "utf8" })));
    return extractPackages(lockData.dependencies);
}
function extractPackages(dependencies) {
    const pkgs = [];
    const deps = dependencies || [];
    Object.keys(deps).forEach((name) => {
        let pkg = {};
        log_verbose(`extract information for ${name}`);
        pkg._name = name;
        pkg._repoName = repoName(name, deps[name]);
        pkg._version = deps[name].version;
        pkg._resolved = deps[name].resolved;
        pkg._integrity = deps[name].integrity;
        pkg._requires = deps[name].requires;
        pkg._dependencies = extractPackages(deps[name].dependencies);
        log_verbose(`repo ${pkg._repoName} depends on ${pkg._dependencies.length} packages : ${JSON.stringify(pkg._dependencies)}`);
        pkgs.push(pkg);
    });
    return pkgs;
}
function flattenDependencies(flattenPkgs, pkgs) {
    pkgs.forEach((pkg) => {
        if (!flattenPkgs.has(pkg._repoName)) {
            flattenPkgs.set(pkg._repoName, pkg);
            flattenDependencies(flattenPkgs, pkg._dependencies);
        }
    });
}
function repoName(name, dep) {
    const version = dep.version || dep._version;
    return `npm__${name
        .replace(/\@/g, "at_")
        .replace(/\'/g, "_")
        .replace(/\//g, "_")}__${version.replace(/\./g, "_")}`;
}
function npm_package(pkg) {
    const deps = "_dependencies" in pkg ? pkg._dependencies : [];
    const required_targets = deps.map((dep) => `"@${repoName(dep._name, dep)}//:pkg"`);
    return `
  if "${pkg._repoName}" not in native.existing_rules():
    install_package(
      name = "${pkg._repoName}",
      pkg = "${pkg._name}",
      version = "${pkg._version}",
      integrity = "${pkg._integrity}",
      url = "${pkg._resolved}",
      required_targets = [${required_targets.join(",")}],
      **kwargs
    )
 `;
}
function generatePackagesBzl(flattenPksg, pkgs) {
    const packages = flattenPksg.map((pkg) => npm_package(pkg));
    const mappings = pkgs.map((pkg) => `"${pkg._name}": "@${pkg._repoName}//:pkg"`);
    return ` # Generated by npm_repositories rule
load("@build_bazel_rules_nodejs//internal/npm_install:npm_repository.bzl", "install_package")

def install_packages(**kwargs):
  ${packages.join("\n")}

_packages = {
  ${mappings.join(",")}
}

all_packages = _packages.values()

def _require(name, target=None):
  name_key = name.lower()
  if name_key not in _packages:
    fail("Could not find npm-provided dependency: '%s'" % name)
  req = _packages[name_key]
  pkg, _, _ = req.partition("//")
  if target != None:
    req = pkg + target
  return req, pkg

def require(name, target=None):
  req, _ = _require(name, target)
  return req

def repo(name):
  _, pkg = _require(name)
  return pkg
`;
}
